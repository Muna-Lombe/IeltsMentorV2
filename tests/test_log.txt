============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.0, pluggy-1.6.0 -- /home/muna/miniconda3/bin/python
cachedir: .pytest_cache
rootdir: /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2
plugins: cov-6.2.1, mock-3.14.1, asyncio-1.0.0, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 38 items

tests/test_handlers.py::test_start_new_user FAILED                       [  2%]
tests/test_handlers.py::test_start_new_user ERROR                        [  2%]
tests/test_handlers.py::test_start_existing_user ERROR                   [  5%]
tests/test_handlers.py::test_start_existing_user ERROR                   [  5%]
tests/test_handlers.py::test_stats_command_with_stats ERROR              [  7%]
tests/test_handlers.py::test_stats_command_with_stats ERROR              [  7%]
tests/test_handlers.py::test_stats_command_no_stats FAILED               [ 10%]
tests/test_handlers.py::test_stats_command_no_stats ERROR                [ 10%]
tests/test_handlers.py::test_practice_command PASSED                     [ 13%]
tests/test_handlers.py::test_practice_section_callback ERROR             [ 15%]
tests/test_handlers.py::test_practice_section_callback ERROR             [ 15%]
tests/test_handlers.py::test_explain_command FAILED                      [ 18%]
tests/test_handlers.py::test_define_command FAILED                       [ 21%]
tests/test_handlers.py::test_unknown_command PASSED                      [ 23%]
tests/test_handlers.py::test_create_group_command_as_approved_teacher ERROR [ 26%]
tests/test_handlers.py::test_create_group_command_as_non_approved_teacher ERROR [ 28%]
tests/test_handlers.py::test_create_group_command_as_regular_user ERROR  [ 31%]
tests/test_handlers.py::test_create_group_command_as_regular_user ERROR  [ 31%]
tests/test_handlers.py::test_create_group_command_as_unknown_user FAILED [ 34%]
tests/test_handlers.py::test_get_group_name_handler ERROR                [ 36%]
tests/test_handlers.py::test_get_group_description_handler ERROR         [ 39%]
tests/test_handlers.py::test_cancel_group_creation_handler ERROR         [ 42%]
tests/test_handlers.py::test_my_exercises_command_with_exercises ERROR   [ 44%]
tests/test_handlers.py::test_my_exercises_command_no_exercises ERROR     [ 47%]
tests/test_handlers.py::test_create_exercise_start_command ERROR         [ 50%]
tests/test_handlers.py::test_create_exercise_get_title ERROR             [ 52%]
tests/test_handlers.py::test_create_exercise_get_description ERROR       [ 55%]
tests/test_handlers.py::test_create_exercise_get_type ERROR              [ 57%]
tests/test_handlers.py::test_create_exercise_get_difficulty ERROR        [ 60%]
tests/test_handlers.py::test_create_exercise_get_content_and_create ERROR [ 63%]
tests/test_handlers.py::test_create_exercise_get_content_invalid ERROR   [ 65%]
tests/test_handlers.py::test_create_exercise_cancel ERROR                [ 68%]
tests/test_models.py::test_user_creation FAILED                          [ 71%]
tests/test_models.py::test_user_creation ERROR                           [ 71%]
tests/test_models.py::test_update_stats ERROR                            [ 73%]
tests/test_models.py::test_update_stats ERROR                            [ 73%]
tests/test_reading_practice.py::test_reading_practice_starts_correctly ERROR [ 76%]
tests/test_reading_practice.py::test_reading_practice_starts_correctly ERROR [ 76%]
tests/test_reading_practice.py::test_handle_reading_answer_correct ERROR [ 78%]
tests/test_reading_practice.py::test_handle_reading_answer_correct ERROR [ 78%]
tests/test_reading_practice.py::test_handle_reading_answer_incorrect ERROR [ 81%]
tests/test_reading_practice.py::test_handle_reading_answer_incorrect ERROR [ 81%]
tests/test_speaking_practice.py::test_start_speaking_practice PASSED     [ 84%]
tests/test_speaking_practice.py::test_handle_part_1 PASSED               [ 86%]
tests/test_student_features.py::test_practice_command_shows_selection_menu ERROR [ 89%]
tests/test_student_features.py::test_practice_command_shows_selection_menu ERROR [ 89%]
tests/test_student_features.py::test_stats_command_displays_user_stats ERROR [ 92%]
tests/test_student_features.py::test_stats_command_displays_user_stats ERROR [ 92%]
tests/test_student_features.py::test_stats_command_for_new_user ERROR    [ 94%]
tests/test_student_features.py::test_stats_command_for_new_user ERROR    [ 94%]
tests/test_student_features.py::test_explain_command_with_valid_query FAILED [ 97%]
tests/test_student_features.py::test_define_command_with_valid_word FAILED [100%]

==================================== ERRORS ====================================
___________________ ERROR at teardown of test_start_new_user ___________________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225105e10>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2255a59f0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
---------------------------- Captured stderr setup -----------------------------
2025-06-17 00:53:43,658 - utils.translation_system - INFO - Loaded translations for en
2025-06-17 00:53:43,659 - utils.translation_system - INFO - Loaded translations for es
------------------------------ Captured log setup ------------------------------
INFO     utils.translation_system:translation_system.py:30 Loaded translations for en
INFO     utils.translation_system:translation_system.py:30 Loaded translations for es
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:43,677 - handlers.decorators - ERROR - Error in handler start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/core_handlers.py", line 19, in start
    user = db.session.query(User).filter_by(user_id=effective_user.id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
------------------------------ Captured log call -------------------------------
ERROR    handlers.decorators:decorators.py:24 Error in handler start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/core_handlers.py", line 19, in start
    user = db.session.query(User).filter_by(user_id=effective_user.id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
__________________ ERROR at setup of test_start_existing_user __________________

self = <sqlalchemy.orm.session.Session object at 0x79d224d742d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d224d742d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225968870>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d224d742d0>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225968870>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
________________ ERROR at teardown of test_start_existing_user _________________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d224d742d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22591a580>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_______________ ERROR at setup of test_stats_command_with_stats ________________

self = <sqlalchemy.orm.session.Session object at 0x79d2258ea890>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2258ea890>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d99c70>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d2258ea890>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d99c70>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
______________ ERROR at teardown of test_stats_command_with_stats ______________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2258ea890>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d997c0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_______________ ERROR at teardown of test_stats_command_no_stats _______________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d22387ced0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f28a0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_______________ ERROR at setup of test_practice_section_callback _______________

self = <sqlalchemy.orm.session.Session object at 0x79d225163e90>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225163e90>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2255065d0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d225163e90>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2255065d0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_____________ ERROR at teardown of test_practice_section_callback ______________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225163e90>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225505310>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_______ ERROR at setup of test_create_group_command_as_approved_teacher ________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 147
  @pytest.mark.asyncio
  async def test_create_group_command_as_approved_teacher(mock_update, mock_context, approved_teacher_user):
      """Test that an approved teacher can start the create group conversation."""
      # This test now checks the entry point of the conversation
      mock_update.effective_user.id = approved_teacher_user.user_id

      # The decorator handles passing the user, so we don't pass it here.
      result_state = await create_group_start(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      # The actual text is now in the 'text' keyword argument
      assert "To create a group, please reply with the group name." in mock_update.message.reply_text.call_args.kwargs['text']
      assert result_state == GET_GROUP_NAME
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:147
_____ ERROR at setup of test_create_group_command_as_non_approved_teacher ______
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 161
  @pytest.mark.asyncio
  async def test_create_group_command_as_non_approved_teacher(mock_update, mock_context, non_approved_teacher_user):
      """Test that a non-approved teacher is denied access."""
      mock_update.effective_user.id = non_approved_teacher_user.user_id

      result = await create_group_start(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "This command is only available to approved teachers" in mock_update.message.reply_text.call_args.kwargs['text']
      assert result == ConversationHandler.END # Decorator should stop the handler
E       fixture 'non_approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:161
_________ ERROR at setup of test_create_group_command_as_regular_user __________

self = <sqlalchemy.orm.session.Session object at 0x79d2255bc650>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2255bc650>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22596a080>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d2255bc650>

    @pytest.fixture(scope='function')
    def regular_user(session):
        """Create a second sample user for testing interactions."""
        user = User(
            user_id=111,
            first_name="Regular",
            last_name="User",
            username="regularuser"
        )
        session.add(user)
>       session.commit()

tests/conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22596a080>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
________ ERROR at teardown of test_create_group_command_as_regular_user ________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2255bc650>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22596bfc0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
________________ ERROR at setup of test_get_group_name_handler _________________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 194
  @pytest.mark.asyncio
  async def test_get_group_name_handler(mock_update, mock_context, approved_teacher_user):
      """Test the handler for receiving the group name."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = "My New Awesome Group"
      mock_context.user_data = {} # Simulate clean user_data

      result_state = await get_group_name(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "please provide a short description" in mock_update.message.reply_text.call_args.kwargs['text']
      assert mock_context.user_data['group_name'] == "My New Awesome Group"
      assert result_state == GET_GROUP_DESCRIPTION
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:194
_____________ ERROR at setup of test_get_group_description_handler _____________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 208
  @pytest.mark.asyncio
  async def test_get_group_description_handler(session, mock_update, mock_context, approved_teacher_user):
      """Test the handler for receiving the description and creating the group."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = "A group for practicing advanced writing."
      mock_context.user_data = {'group_name': 'Advanced Writers'}

      result_state = await get_group_description(mock_update, mock_context)

      # Check that the success message was sent
      mock_update.message.reply_text.assert_called_once()
      assert "Group 'Advanced Writers' has been created successfully!" in mock_update.message.reply_text.call_args.kwargs['text']

      # Check that the group was actually created in the DB
      new_group = session.query(Group).filter_by(name='Advanced Writers').first()
      assert new_group is not None
      assert new_group.teacher_id == approved_teacher_user.id
      assert new_group.description == "A group for practicing advanced writing."

      # Check that state was cleaned up and conversation ended
      assert 'group_name' not in mock_context.user_data
      assert result_state == ConversationHandler.END
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:208
_____________ ERROR at setup of test_cancel_group_creation_handler _____________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 231
  @pytest.mark.asyncio
  async def test_cancel_group_creation_handler(mock_update, mock_context, approved_teacher_user):
      """Test the cancellation of the group creation flow."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_context.user_data = {'group_name': 'A Group To Be Cancelled'}

      result_state = await cancel_group_creation(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once_with(text="Group creation has been cancelled.")
      assert 'group_name' not in mock_context.user_data
      assert result_state == ConversationHandler.END
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:231
__________ ERROR at setup of test_my_exercises_command_with_exercises __________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 243
  @pytest.mark.asyncio
  async def test_my_exercises_command_with_exercises(mock_update, mock_context, approved_teacher_with_exercises):
      """Test the /my_exercises command for a teacher who has created exercises."""
      mock_update.effective_user.id = approved_teacher_with_exercises.user_id

      await my_exercises_command(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      response_text = mock_update.message.reply_text.call_args.kwargs['text']

      assert "Here are your created exercises:" in response_text
      assert "Grammar Test 1" in response_text
      assert "Vocabulary Quiz" in response_text
      assert "Published" in response_text
      assert "Draft" in response_text
E       fixture 'approved_teacher_with_exercises' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:243
___________ ERROR at setup of test_my_exercises_command_no_exercises ___________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 259
  @pytest.mark.asyncio
  async def test_my_exercises_command_no_exercises(mock_update, mock_context, approved_teacher_user):
      """Test the /my_exercises command for a teacher with no exercises."""
      mock_update.effective_user.id = approved_teacher_user.user_id

      await my_exercises_command(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      response_text = mock_update.message.reply_text.call_args.kwargs['text']

      assert "You have not created any exercises yet" in response_text
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:259
_____________ ERROR at setup of test_create_exercise_start_command _____________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 272
  @pytest.mark.asyncio
  async def test_create_exercise_start_command(mock_update, mock_context, approved_teacher_user):
      """Test the start of the /create_exercise conversation."""
      mock_update.effective_user.id = approved_teacher_user.user_id

      result = await create_exercise_start(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "First, what is the title" in mock_update.message.reply_text.call_args.kwargs['text']
      assert result == GET_TITLE
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:272
_______________ ERROR at setup of test_create_exercise_get_title _______________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 283
  @pytest.mark.asyncio
  async def test_create_exercise_get_title(mock_update, mock_context, approved_teacher_user):
      """Test the get_title step of the conversation."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = "My First Exercise"
      mock_context.user_data = {}

      result = await get_title(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "provide a short description" in mock_update.message.reply_text.call_args.kwargs['text']
      assert mock_context.user_data['title'] == "My First Exercise"
      assert result == GET_DESCRIPTION
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:283
____________ ERROR at setup of test_create_exercise_get_description ____________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 297
  @pytest.mark.asyncio
  async def test_create_exercise_get_description(mock_update, mock_context, approved_teacher_user):
      """Test the get_description step of the conversation."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = "A simple exercise."
      mock_context.user_data = {"title": "My First Exercise"}

      result = await get_description(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "select the exercise type" in mock_update.message.reply_text.call_args.kwargs['text']
      assert isinstance(mock_update.message.reply_text.call_args.kwargs['reply_markup'], InlineKeyboardMarkup)
      assert mock_context.user_data['description'] == "A simple exercise."
      assert result == GET_TYPE
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:297
_______________ ERROR at setup of test_create_exercise_get_type ________________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 312
  @pytest.mark.asyncio
  async def test_create_exercise_get_type(mock_update, mock_context, approved_teacher_user):
      """Test the get_type step of the conversation."""
      mock_context.user_data = {"title": "My First Exercise", "description": "A simple exercise."}

      # Simulate a callback query
      mock_update.callback_query = AsyncMock()
      mock_update.callback_query.data = "type_grammar"
      mock_update.callback_query.from_user.id = approved_teacher_user.user_id

      result = await get_type(mock_update, mock_context)

      mock_update.callback_query.answer.assert_called_once()
      mock_update.callback_query.edit_message_text.assert_called_once()
      assert "difficulty level" in mock_update.callback_query.edit_message_text.call_args.kwargs['text']
      assert mock_context.user_data['type'] == "grammar"
      assert result == GET_DIFFICULTY
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:312
____________ ERROR at setup of test_create_exercise_get_difficulty _____________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 330
  @pytest.mark.asyncio
  async def test_create_exercise_get_difficulty(mock_update, mock_context, approved_teacher_user):
      """Test the get_difficulty step of the conversation."""
      mock_context.user_data = {"title": "My First Exercise", "description": "A simple exercise.", "type": "grammar"}

      mock_update.callback_query = AsyncMock()
      mock_update.callback_query.data = "difficulty_intermediate"
      mock_update.callback_query.from_user.id = approved_teacher_user.user_id

      result = await get_difficulty(mock_update, mock_context)

      mock_update.callback_query.answer.assert_called_once()
      mock_update.callback_query.edit_message_text.assert_called_once()
      assert "provide the exercise content" in mock_update.callback_query.edit_message_text.call_args.kwargs['text']
      assert mock_context.user_data['difficulty'] == "intermediate"
      assert result == GET_CONTENT
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:330
________ ERROR at setup of test_create_exercise_get_content_and_create _________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 347
  @pytest.mark.asyncio
  async def test_create_exercise_get_content_and_create(session, mock_update, mock_context, approved_teacher_user):
      """Test the final step of creating the exercise with valid content."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = '{"questions": [{"text": "This is a valid question."}]}'
      mock_context.user_data = {
          "title": "My First Exercise",
          "description": "A simple exercise.",
          "type": "grammar",
          "difficulty": "intermediate"
      }

      result = await get_content(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "Exercise created successfully" in mock_update.message.reply_text.call_args.kwargs['text']

      # Verify in DB
      exercise = session.query(TeacherExercise).filter_by(title="My First Exercise").first()
      assert exercise is not None
      assert exercise.creator_id == approved_teacher_user.id
      assert exercise.content['questions'][0]['text'] == "This is a valid question."

      assert result == ConversationHandler.END
      assert not mock_context.user_data # user_data should be cleared
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:347
__________ ERROR at setup of test_create_exercise_get_content_invalid __________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 373
  @pytest.mark.asyncio
  async def test_create_exercise_get_content_invalid(mock_update, mock_context, approved_teacher_user):
      """Test providing invalid content for an exercise."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_update.message.text = "This is not valid JSON."
      mock_context.user_data = {
          "title": "My First Exercise",
          "description": "A simple exercise.",
          "type": "grammar",
          "difficulty": "intermediate"
      }

      result = await get_content(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "The content format is invalid" in mock_update.message.reply_text.call_args.kwargs['text']
      assert result == GET_CONTENT # Should stay in the same state
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:373
________________ ERROR at setup of test_create_exercise_cancel _________________
file /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py, line 391
  @pytest.mark.asyncio
  async def test_create_exercise_cancel(mock_update, mock_context, approved_teacher_user):
      """Test the cancellation of the /create_exercise conversation."""
      mock_update.effective_user.id = approved_teacher_user.user_id
      mock_context.user_data = {"title": "An exercise to be cancelled"}

      result = await cancel_exercise_creation(mock_update, mock_context)

      mock_update.message.reply_text.assert_called_once()
      assert "Exercise creation has been cancelled" in mock_update.message.reply_text.call_args.kwargs['text']
      assert not mock_context.user_data
      assert result == ConversationHandler.END
E       fixture 'approved_teacher_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, _translations, anyio_backend, anyio_backend_name, anyio_backend_options, app, approved_teacher, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_context, mock_openai_service, mock_reading_data, mock_update, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, regular_user, sample_teacher_with_exercises, sample_user, session, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unapproved_teacher, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/tests/test_handlers.py:391
___________________ ERROR at teardown of test_user_creation ____________________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d224d7c6d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dda120>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_____________________ ERROR at setup of test_update_stats ______________________

self = <sqlalchemy.orm.session.Session object at 0x79d2258eacd0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2258eacd0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225158910>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d2258eacd0>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225158910>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
____________________ ERROR at teardown of test_update_stats ____________________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2258eacd0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251583c0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
___________ ERROR at setup of test_reading_practice_starts_correctly ___________

self = <sqlalchemy.orm.session.Session object at 0x79d225148a90>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225148a90>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251580f0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d225148a90>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251580f0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_________ ERROR at teardown of test_reading_practice_starts_correctly __________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225148a90>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2255a4a00>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_____________ ERROR at setup of test_handle_reading_answer_correct _____________

self = <sqlalchemy.orm.session.Session object at 0x79d225562950>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225562950>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225506ee0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d225562950>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225506ee0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
___________ ERROR at teardown of test_handle_reading_answer_correct ____________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d225562950>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d225504780>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
____________ ERROR at setup of test_handle_reading_answer_incorrect ____________

self = <sqlalchemy.orm.session.Session object at 0x79d22517e2d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d22517e2d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f2170>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d22517e2d0>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f2170>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
__________ ERROR at teardown of test_handle_reading_answer_incorrect ___________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d22517e2d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f17c0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
_________ ERROR at setup of test_practice_command_shows_selection_menu _________

self = <sqlalchemy.orm.session.Session object at 0x79d223d24e10>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d223d24e10>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dd8fa0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d223d24e10>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dd8fa0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_______ ERROR at teardown of test_practice_command_shows_selection_menu ________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d223d24e10>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dd8230>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
___________ ERROR at setup of test_stats_command_displays_user_stats ___________

self = <sqlalchemy.orm.session.Session object at 0x79d2255f1590>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2255f1590>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22515adf0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d2255f1590>

    @pytest.fixture(scope='function')
    def sample_user(session):
        """Create a sample user in the database for a single test."""
        user = User(
            user_id=12345,
            first_name="Test",
            last_name="User",
            username="testuser",
            preferred_language="en",
            stats={'reading': {'correct': 5, 'total': 10}}
        )
        session.add(user)
>       session.commit()

tests/conftest.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22515adf0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_________ ERROR at teardown of test_stats_command_displays_user_stats __________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2255f1590>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d22515b160>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
______________ ERROR at setup of test_stats_command_for_new_user _______________

self = <sqlalchemy.orm.session.Session object at 0x79d2241262d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2241262d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d64dc0>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d2241262d0>

    @pytest.fixture(scope='function')
    def regular_user(session):
        """Create a second sample user for testing interactions."""
        user = User(
            user_id=111,
            first_name="Regular",
            last_name="User",
            username="regularuser"
        )
        session.add(user)
>       session.commit()

tests/conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d64dc0>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_____________ ERROR at teardown of test_stats_command_for_new_user _____________

app = <Flask 'app'>

    @pytest.fixture(scope='function')
    def session(app):
        """
        Creates a new database session for a test with nested transactions.
        Rolls back to a savepoint after each test, ensuring test isolation.
        """
        connection = engine.connect()
        transaction = connection.begin()
    
        # The session is bound to the connection, ensuring it participates in the transaction
        db_session = TestingSessionLocal(bind=connection)
    
        # Establish a SAVEPOINT, and roll back to it after the test
        nested = connection.begin_nested()
    
        @event.listens_for(db_session, "after_transaction_end")
        def end_savepoint(session, transaction):
            # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
            if not nested.is_active:
                nested = connection.begin_nested()
    
        yield db_session
    
        # Rollback the overall transaction and close the connection
>       db_session.close()

tests/conftest.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2507: in close
    self._close_impl(invalidate=False)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2576: in _close_impl
    transaction.close(invalidate)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d2241262d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d224d65e00>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError
=================================== FAILURES ===================================
_____________________________ test_start_new_user ______________________________

session = <sqlalchemy.orm.session.Session object at 0x79d225105e10>
mock_update = <MagicMock spec='Update' id='133943476988688'>
mock_context = <MagicMock id='133943472113616'>

    @pytest.mark.asyncio
    async def test_start_new_user(session, mock_update, mock_context):
        """Test the /start command for a new user."""
        await start(mock_update, mock_context)
        new_user = session.query(User).filter_by(user_id=12345).first()
>       assert new_user is not None
E       assert None is not None

tests/test_handlers.py:48: AssertionError
---------------------------- Captured stderr setup -----------------------------
2025-06-17 00:53:43,658 - utils.translation_system - INFO - Loaded translations for en
2025-06-17 00:53:43,659 - utils.translation_system - INFO - Loaded translations for es
------------------------------ Captured log setup ------------------------------
INFO     utils.translation_system:translation_system.py:30 Loaded translations for en
INFO     utils.translation_system:translation_system.py:30 Loaded translations for es
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:43,677 - handlers.decorators - ERROR - Error in handler start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/core_handlers.py", line 19, in start
    user = db.session.query(User).filter_by(user_id=effective_user.id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
------------------------------ Captured log call -------------------------------
ERROR    handlers.decorators:decorators.py:24 Error in handler start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/core_handlers.py", line 19, in start
    user = db.session.query(User).filter_by(user_id=effective_user.id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
_________________________ test_stats_command_no_stats __________________________

self = <sqlalchemy.orm.session.Session object at 0x79d22387ced0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d22387ced0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f2b20>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d22387ced0>
mock_update = <MagicMock spec='Update' id='133943446197008'>
mock_context = <MagicMock id='133943451081744'>

    @pytest.mark.asyncio
    async def test_stats_command_no_stats(session, mock_update, mock_context):
        """Test the /stats command for a new user with default 0 stats."""
        user = User(user_id=54321, first_name="Newbie")
        mock_update.effective_user.id = 54321
        session.add(user)
>       session.commit()

tests/test_handlers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
<string>:2: in rollback
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d2251f2b20>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
_____________________________ test_explain_command _____________________________

mock_openai_service_class = <MagicMock name='OpenAIService' id='133943451968848'>
mock_update = <MagicMock spec='Update' id='133943472679888'>
mock_context = <MagicMock id='133943446207632'>

    @pytest.mark.asyncio
    @patch("handlers.ai_commands_handler.OpenAIService")
    async def test_explain_command(mock_openai_service_class, mock_update, mock_context):
        """Test the /explain command with a mocked AI service."""
        mock_service_instance = mock_openai_service_class.return_value
        mock_service_instance.generate_explanation.return_value = "This is a mock explanation."
    
        mock_context.args = ["grammar", "present", "perfect"]
        await explain_command(mock_update, mock_context)
    
        # The handler now sends a single "general_error" for simplicity
        mock_update.message.reply_text.assert_called_once()
>       assert "Sorry, I couldn't process that" in mock_update.message.reply_text.call_args.kwargs['text']
                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'text'

tests/test_handlers.py:123: KeyError
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:44,856 - utils.translation_system - ERROR - Message not found for ai.thinking in any language
2025-06-17 00:53:44,857 - utils.translation_system - ERROR - Message not found for ai.explanation_header in any language
------------------------------ Captured log call -------------------------------
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.thinking in any language
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.explanation_header in any language
_____________________________ test_define_command ______________________________

mock_openai_service_class = <MagicMock name='OpenAIService' id='133943468213328'>
mock_update = <MagicMock spec='Update' id='133943472119760'>
mock_context = <MagicMock id='133943472015952'>

    @pytest.mark.asyncio
    @patch("handlers.ai_commands_handler.OpenAIService")
    async def test_define_command(mock_openai_service_class, mock_update, mock_context):
        """Test the /define command with a mocked AI service."""
        mock_service_instance = mock_openai_service_class.return_value
        mock_service_instance.generate_definition.return_value = "This is a mock definition."
    
        mock_context.args = ["elaborate"]
        await define_command(mock_update, mock_context)
    
        mock_update.message.reply_text.assert_called_once()
>       assert "Sorry, I couldn't process that" in mock_update.message.reply_text.call_args.kwargs['text']
                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'text'

tests/test_handlers.py:136: KeyError
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:44,868 - utils.translation_system - ERROR - Message not found for ai.thinking in any language
2025-06-17 00:53:44,869 - utils.translation_system - ERROR - Message not found for ai.definition_header in any language
------------------------------ Captured log call -------------------------------
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.thinking in any language
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.definition_header in any language
__________________ test_create_group_command_as_unknown_user ___________________

mock_update = <MagicMock spec='Update' id='133943455268944'>
mock_context = <MagicMock id='133943472500624'>

    @pytest.mark.asyncio
    async def test_create_group_command_as_unknown_user(mock_update, mock_context):
        """Test that a user not in the database is denied access."""
        mock_update.effective_user.id = 999999  # An ID that doesn't exist
    
        result = await create_group_start(mock_update, mock_context)
    
        mock_update.message.reply_text.assert_called_once()
>       assert "Could not find your user profile" in mock_update.message.reply_text.call_args.kwargs['text']
E       AssertionError: assert 'Could not find your user profile' in 'Sorry, something went wrong. Please try again later.'

tests/test_handlers.py:191: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:45,151 - handlers.decorators - ERROR - Error in handler create_group_start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 42, in wrapper
    user = db.session.query(User).filter(User.user_id == user_id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
------------------------------ Captured log call -------------------------------
ERROR    handlers.decorators:decorators.py:24 Error in handler create_group_start: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
Traceback (most recent call last):
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 21, in wrapper
    return await func(update, context, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/decorators.py", line 42, in wrapper
    user = db.session.query(User).filter(User.user_id == user_id).first()
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 1683, in query
    return self._proxied.query(*entities, **kwargs)
           ^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py", line 197, in _proxied
    return self.registry()
           ^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/_collections.py", line 632, in __call__
    key = self.scopefunc()
          ^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/flask_sqlalchemy/session.py", line 111, in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/muna/miniconda3/lib/python3.11/site-packages/werkzeug/local.py", line 519, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.
______________________________ test_user_creation ______________________________

self = <sqlalchemy.orm.session.Session object at 0x79d224d7c6d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
>           transaction.commit()

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1317: in commit
    self.close()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1423: in close
    sess.dispatch.after_transaction_end(sess, self)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/event/attr.py:497: in __call__
    fn(*args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <sqlalchemy.orm.session.Session object at 0x79d224d7c6d0>
transaction = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dd8820>

    @event.listens_for(db_session, "after_transaction_end")
    def end_savepoint(session, transaction):
        # When the session ends (e.g., via commit or rollback), if the nested transaction is still active, roll it back
>       if not nested.is_active:
               ^^^^^^
E       UnboundLocalError: cannot access local variable 'nested' where it is not associated with a value

tests/conftest.py:58: UnboundLocalError

During handling of the above exception, another exception occurred:

session = <sqlalchemy.orm.session.Session object at 0x79d224d7c6d0>

    def test_user_creation(session):
        """Test basic user creation and default values."""
        user = User(
            user_id=98765,
            first_name="Test",
            last_name="User",
            username="testuser_models",
            preferred_language="en"
        )
        session.add(user)
>       session.commit()

tests/test_models.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2017: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1302: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1277: in _prepare_impl
    self.session.flush()
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4341: in flush
    self._flush(objects)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4476: in _flush
    with util.safe_reraise():
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:150: in __exit__
    raise value.with_traceback(traceback)
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4477: in _flush
    transaction.rollback(_capture_exception=True)
<string>:2: in rollback
    ???
/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:103: in _go
    self._raise_for_prerequisite_state(fn.__name__, current_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x79d223dd8820>
operation_name = 'rollback', state = <SessionTransactionState.CLOSED: 5>

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
>           raise sa_exc.ResourceClosedError("This transaction is closed")
E           sqlalchemy.exc.ResourceClosedError: This transaction is closed

/home/muna/miniconda3/lib/python3.11/site-packages/sqlalchemy/orm/session.py:988: ResourceClosedError
____________________ test_explain_command_with_valid_query _____________________

self = <MagicMock name='OpenAIService.generate_explanation' id='133943467908944'>
args = ()
kwargs = {'context': 'grammar', 'language': 'en', 'query': 'present perfect'}
msg = "Expected 'generate_explanation' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'generate_explanation' to be called once. Called 0 times.

/home/muna/miniconda3/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

mock_update = <MagicMock spec='Update' id='133943480233936'>
mock_context = <MagicMock id='133943468379024'>
mock_openai_service = <MagicMock name='OpenAIService' id='133943467908560'>

    @pytest.mark.asyncio
    async def test_explain_command_with_valid_query(mock_update, mock_context, mock_openai_service):
        """
        Tests the /explain command with a valid query, ensuring it calls the AI service.
        """
        mock_context.args = ["grammar", "present", "perfect"]
    
        from handlers.ai_commands_handler import explain_command
        await explain_command(mock_update, mock_context)
    
        # Check that the AI service was called
>       mock_openai_service.generate_explanation.assert_called_once_with(
            query="present perfect", context="grammar", language="en"
        )
E       AssertionError: Expected 'generate_explanation' to be called once. Called 0 times.

tests/test_student_features.py:92: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:47,198 - utils.translation_system - ERROR - Message not found for ai.thinking in any language
2025-06-17 00:53:47,199 - utils.translation_system - ERROR - Message not found for ai.explanation_header in any language
------------------------------ Captured log call -------------------------------
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.thinking in any language
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.explanation_header in any language
_____________________ test_define_command_with_valid_word ______________________

self = <MagicMock name='OpenAIService.generate_definition' id='133943468605776'>
args = (), kwargs = {'language': 'en', 'word': 'elaborate'}
msg = "Expected 'generate_definition' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'generate_definition' to be called once. Called 0 times.

/home/muna/miniconda3/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

mock_update = <MagicMock spec='Update' id='133943476256464'>
mock_context = <MagicMock id='133943468227664'>
mock_openai_service = <MagicMock name='OpenAIService' id='133943476576464'>

    @pytest.mark.asyncio
    async def test_define_command_with_valid_word(mock_update, mock_context, mock_openai_service):
        """
        Tests the /define command with a valid word, ensuring it calls the AI service.
        """
        mock_context.args = ["elaborate"]
    
        from handlers.ai_commands_handler import define_command
        await define_command(mock_update, mock_context)
    
        # Check that the AI service was called
>       mock_openai_service.generate_definition.assert_called_once_with(
            word="elaborate", language="en"
        )
E       AssertionError: Expected 'generate_definition' to be called once. Called 0 times.

tests/test_student_features.py:112: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-06-17 00:53:47,248 - utils.translation_system - ERROR - Message not found for ai.thinking in any language
2025-06-17 00:53:47,249 - utils.translation_system - ERROR - Message not found for ai.definition_header in any language
------------------------------ Captured log call -------------------------------
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.thinking in any language
ERROR    utils.translation_system:translation_system.py:50 Message not found for ai.definition_header in any language
=============================== warnings summary ===============================
../../../../../../../miniconda3/lib/python3.11/site-packages/pydub/utils.py:14
  /home/muna/miniconda3/lib/python3.11/site-packages/pydub/utils.py:14: DeprecationWarning: 'audioop' is deprecated and slated for removal in Python 3.13
    import audioop

handlers/exercise_management_handler.py:215
  /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/exercise_management_handler.py:215: PTBUserWarning: If 'per_message=False', 'CallbackQueryHandler' will not be tracked for every message. Read this FAQ entry to learn more about the per_* settings: https://github.com/python-telegram-bot/python-telegram-bot/wiki/Frequently-Asked-Questions#what-do-the-per_-settings-in-conversationhandler-do.
    create_exercise_conv_handler = ConversationHandler(

handlers/speaking_practice_handler.py:167
  /home/muna/code/Muna-Lombe/tutorials/PythOn/telegram/bots/IeltsMentorV2/handlers/speaking_practice_handler.py:167: PTBUserWarning: If 'per_message=False', 'CallbackQueryHandler' will not be tracked for every message. Read this FAQ entry to learn more about the per_* settings: https://github.com/python-telegram-bot/python-telegram-bot/wiki/Frequently-Asked-Questions#what-do-the-per_-settings-in-conversationhandler-do.
    speaking_practice_conv_handler = ConversationHandler(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_handlers.py::test_start_new_user - assert None is not None
FAILED tests/test_handlers.py::test_stats_command_no_stats - sqlalchemy.exc.R...
FAILED tests/test_handlers.py::test_explain_command - KeyError: 'text'
FAILED tests/test_handlers.py::test_define_command - KeyError: 'text'
FAILED tests/test_handlers.py::test_create_group_command_as_unknown_user - As...
FAILED tests/test_models.py::test_user_creation - sqlalchemy.exc.ResourceClos...
FAILED tests/test_student_features.py::test_explain_command_with_valid_query
FAILED tests/test_student_features.py::test_define_command_with_valid_word - ...
ERROR tests/test_handlers.py::test_start_new_user - UnboundLocalError: cannot...
ERROR tests/test_handlers.py::test_start_existing_user - sqlalchemy.exc.Resou...
ERROR tests/test_handlers.py::test_start_existing_user - UnboundLocalError: c...
ERROR tests/test_handlers.py::test_stats_command_with_stats - sqlalchemy.exc....
ERROR tests/test_handlers.py::test_stats_command_with_stats - UnboundLocalErr...
ERROR tests/test_handlers.py::test_stats_command_no_stats - UnboundLocalError...
ERROR tests/test_handlers.py::test_practice_section_callback - sqlalchemy.exc...
ERROR tests/test_handlers.py::test_practice_section_callback - UnboundLocalEr...
ERROR tests/test_handlers.py::test_create_group_command_as_approved_teacher
ERROR tests/test_handlers.py::test_create_group_command_as_non_approved_teacher
ERROR tests/test_handlers.py::test_create_group_command_as_regular_user - sql...
ERROR tests/test_handlers.py::test_create_group_command_as_regular_user - Unb...
ERROR tests/test_handlers.py::test_get_group_name_handler
ERROR tests/test_handlers.py::test_get_group_description_handler
ERROR tests/test_handlers.py::test_cancel_group_creation_handler
ERROR tests/test_handlers.py::test_my_exercises_command_with_exercises
ERROR tests/test_handlers.py::test_my_exercises_command_no_exercises
ERROR tests/test_handlers.py::test_create_exercise_start_command
ERROR tests/test_handlers.py::test_create_exercise_get_title
ERROR tests/test_handlers.py::test_create_exercise_get_description
ERROR tests/test_handlers.py::test_create_exercise_get_type
ERROR tests/test_handlers.py::test_create_exercise_get_difficulty
ERROR tests/test_handlers.py::test_create_exercise_get_content_and_create
ERROR tests/test_handlers.py::test_create_exercise_get_content_invalid
ERROR tests/test_handlers.py::test_create_exercise_cancel
ERROR tests/test_models.py::test_user_creation - UnboundLocalError: cannot ac...
ERROR tests/test_models.py::test_update_stats - sqlalchemy.exc.ResourceClosed...
ERROR tests/test_models.py::test_update_stats - UnboundLocalError: cannot acc...
ERROR tests/test_reading_practice.py::test_reading_practice_starts_correctly
ERROR tests/test_reading_practice.py::test_reading_practice_starts_correctly
ERROR tests/test_reading_practice.py::test_handle_reading_answer_correct - sq...
ERROR tests/test_reading_practice.py::test_handle_reading_answer_correct - Un...
ERROR tests/test_reading_practice.py::test_handle_reading_answer_incorrect - ...
ERROR tests/test_reading_practice.py::test_handle_reading_answer_incorrect - ...
ERROR tests/test_student_features.py::test_practice_command_shows_selection_menu
ERROR tests/test_student_features.py::test_practice_command_shows_selection_menu
ERROR tests/test_student_features.py::test_stats_command_displays_user_stats
ERROR tests/test_student_features.py::test_stats_command_displays_user_stats
ERROR tests/test_student_features.py::test_stats_command_for_new_user - sqlal...
ERROR tests/test_student_features.py::test_stats_command_for_new_user - Unbou...
============== 8 failed, 4 passed, 3 warnings, 40 errors in 3.74s ==============
